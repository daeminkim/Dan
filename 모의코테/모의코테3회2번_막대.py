# 문제 설명
# 윤호는 64 cm 길이의 막대를 가지고 있지만 x cm만큼 긴 막대가 있다면 더 재밌을 것이라 생각한다. 그는 원래 막대를 작은 막대 여러개로 부수고 풀로 붙여서 정확히 x cm만큼 긴 막대를 만들기로 결심했다.

# 막대를 부수는 가장 쉬운 방법은 반으로 쪼개는 것이라서 윤호는 다음의 방법을 따르기로 했다:

# 모든 막대들의 길이를 더한다 (처음에는 64 cm 길이의 막대 하나만 있었다). 길이의 합이 x보다 크다면 다음을 반복한다:
# 가장 짧은 길이의 막대를 반으로 부순다.
# 만약 두개 중 하나를 버려도 남아있는 막대들의 길이의 합이 x보다 크다면 하나를 버린다.
# 마지막으로 남아있는 막대들을 풀로 붙여 x cm길이의 막대를 만든다.

# 윤호가 위의 단계를 따라하여 풀로 붙이게 될 마지막에 남은 막대들의 개수를 반환하여라. 만약 마지막 단계에서 막대가 하나밖에 없다면 1을 반환하라 (예제 1을 참고하여라).

# 참고 / 제약 사항
# 문제 내용에 설명된 알고리즘은 마지막 단계에서 언제나 정확히 최종 길이가 x로 끝나는 것을 보장한다.
# x는 최소값 1, 최대값 64의 범위를 갖는다.

# x = 2
# bar = 64
# piece = []
# count = 0
# while bar>1:
#     piece.append(bar)
#     bar = bar//2
# print(piece)

# for i in piece:
#     if x >= i:
#         x = x - i
#         count +=1
# if count == 0:
#     print(1) 
     
# print(count)

#테스트 케이스
# x = 32리턴(정답): 1
# 한번만 막대를 부수면 32cm 길이의 막대를 얻는다.

# x = 48리턴(정답): 2
# 먼저 막대를 부수어 32cm 길이의 막대 2개를 구한다. 그리고 나서 32cm 막대 중에 하나를 반으로 부수고 그 중의 반을 버린다. 나머지 2개의 막대를 붙이면 48cm의 막대가 된다.

# x = 10리턴(정답): 2
# x = 1리턴(정답): 1
# x = 2리턴(정답): 1





# 정답 코드

#핵심 소스코드의 설명을 주석으로 작성하면 평가에 큰 도움이 됩니다.
class Solution:
    def solution(self, x):
        self.x = x
        bar = 64
        piece = []   # 막대를 쪼갰을 때 나오는 모든 경우의 막대 길이
        count = 0
        while bar>1:  # 막대를 쪼갰을 때 나오는 모든 경우의 막대 길이 구하기 
            piece.append(bar)
            bar = bar//2
        piece.append(1)
        
        for i in piece:
            if x >= i:
                x = x - i
                count +=1
     
        return count

